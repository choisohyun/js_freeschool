## :three: 다각형의 넓이 구하기
### Scope(범위, 가시성)
- 정의: 프로그램의 *실행 컨텍스트*에서 현재 보이고 접근 가능한 식별자들
- 변수, 상수, 매개변수가 언제 어디서 정의되는지 결정함
### 정적 스코프
- 어떤 변수가 함수 스코프 안에 있는지 함수를 선언할 때(호출할 때가 아님) 알 수 있음. 
- 자바스크립트의 스코프.
- **선언될 때** 접근 가능한 식별자      ==> 접근 가능
- **호출할 때** 스코프에 있는 식별자    ==> 접근 불가능
- 전역 스코프, 블록 스코프, 함수 스코프에 적용



### 전역 스코프
- 프로그램을 시작할 때 암시적으로 주어지는 스코프
- 전역 스코프에 있는 것은 모든 스코프에서 보임
- 전역 변수: 전역 스코프에 선언된 것들 (전역변수 남용 X)
- **전역 스코프에 의존하는 것**을 피해야 함

### 블록 스코프
- 해당 블록의 스코프에서만 보이는 식별자(변수 숨기기)
- `let, const`로 식별자 선언(`var`는 지원하지 않음)
- 독립 블록도 사용 가능
- 현실적으로 사용하는 경우는 별로 없음

### 함수 스코프
- `var`로 식별자 선언

### 실행 컨텍스트
- 코드가 실행되기 위해 필요한 정보를 가지고 있음
- 실행순서: 전역코드-> 전역 컨텍스트 -> 함수 호출문 -> 새로운 실행 컨텍스트, ...
- `스택(stack)`을 이용해 실행 컨텍스트 관리
- 실행 후에는 제거됨
- 렉시컬 환경을 가지고 있음


### 스코프 체인
- 꼬리를 물고 계속 범위를 넓히면서 찾는 관계
- 예) inner() scope --> outer() scope --> global scope --> undefined error

### 클로저
- 함수가 정의될 때의 렉시컬 환경을 기억하는 것
- 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것
- 스코프를 함수 주변으로 좁히는 것

### 즉시 호출 함수 표현(IIFE)
- `(function() {})();`

### 함수 호이스팅
- 함수 선언을 스코프 맨 위로 끌어올림
- `변수에 할당한 함수 표현식`은 끌어올리지 않음

### var로 선언된 변수
- Hoisting(선언을 끌어올린다)을 따름
- 함수, 전역 스코프 전체를 살펴보고 var로 선언한 변수를 맨 위로 끌어올림
- 할당은 끌어올려지지 않음
- 블록 단위를 사용할 때는 var보다 let을 쓰는 것 권장
- 재선언, 재할당 가능
```
var name = 'sohyun';
var name = 'pengsoo'; //가능
name = 'gildong';   // 가능
```


### const로 선언된 변수
- 재선언, 재할당 불가
```
const name = 'sohyun';
const name = 'pengsoo'; //SyntaxError
nams = 'gildong';   // TypeError
```
- 배열, 객체 값 변경 가능

### let으로 선언된 변수
- 재선언 불가, 재할당 가능
```
let latte = 'sohyun';
let latte = 'pengsoo';  // SyntaxError
latte = 'gildong';  // 가능
```

